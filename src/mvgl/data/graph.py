import copy
import networkx as nx
import numpy as np

from mvgl import exceptions

def ensure_connectedness(generator):
    """Draw a random graph until finding a connected one."""
    i = 1
    while True:
        G = generator()
        if nx.is_connected(G):
            return G
        else:
            i += 1

        if i>500:
            return None
        
def swap_edges(G, n_swaps, rng=None):
    """Swap edges of an input graph to generate another graph. 
    
    The method randomly select an edge: (a, b) and two nodes c and d that are
    not connected. Edge (a, b) is then removed and a new edge (c, d) is added.
    All attributes of (a, b) are also transfered to the newly added edge (c, d).
    Edge swapping is done in place. There is an edge swapping function in
    networkx, but it does not handle edge attributes.

    Parameters
    ----------
    G : nx.Graph
        An undirected graph.
    n_swaps : int
        Number of edge swap to perform.
    rng : np.random.Generator, optional
        Random number generator. If one wants the function to return the same 
        output every time, this needs to be set. By default None

    Returns
    -------
    G : nx.Graph
        The new graph generated by edge swapping.
    """
    if rng is None: 
        rng = np.random.default_rng()

    G = copy.deepcopy(G)

    n = G.number_of_nodes()
    m = G.number_of_edges()

    # If the graph is fully connected, there is nothing to randomize
    if m == (n*(n-1)/2):
        return
    
    # Get the nodes of the graph as a list
    node_labels = [i for i in G.nodes]

    max_attempt = m
    for _ in range(n_swaps):     

        # Select an edge to swap: ensures that a and b have at least two edges
        attempt = 0
        while attempt <= max_attempt:
            a = rng.choice(node_labels)

            if G.degree(a) > 1:
                b = rng.choice(list(G.neighbors(a)))
            
                if G.degree(b) > 1:
                    break

        # Select two nodes to connect with an edge
        attempt = 0
        while attempt <= max_attempt:
            c = rng.choice(node_labels)
            d = rng.choice(node_labels)

            if c != b and c != a and d!=a and d != b and (not G.has_edge(c, d)):
                break
                
            attempt += 1
        
        # Rewire the edge
        attr_ab = G[a][b]
        G.remove_edge(a, b)
        G.add_edge(c, d, **attr_ab)

    return G

def gen_consensus_graph(n_nodes, graph_generator, p=None, m=None, rng=None):
    """Generate the consensus graph using Erdos-Renyi or Barabasi-Albert model.

    Parameters
    ----------
    n_nodes : int
        Number of nodes
    graph_generator : str
        The model to use. Must be 'er' or 'ba'.
    p : float, optional
        The edge probability for Erdos-Renyi model. Ignored if graph_generator
        is 'ba'. By default None.
    m : int, optional
        Growth parameter for Barabasi-Albert model. Ignored if graph generator
        is 'er'. By default None
    rng : np.random.Generator, optional
        Random number generator. If one wants the function to return the same 
        output every time, this needs to be set. By default None

    Returns
    -------
    G : nx.Graph
        Generated consensus graph

    Raises
    ------
    MaxIterReachedException
        This function keeps drawing a random graph until finding a connected
        one. Maximum number of draws is set to 500. If this reached it will
        raise an error. 
    """
    if rng is None: 
        rng = np.random.default_rng()

    if graph_generator == "er":
        graph_generator = lambda : nx.erdos_renyi_graph(n_nodes, p, seed=rng)
    elif graph_generator == "ba":
        graph_generator = lambda : nx.barabasi_albert_graph(n_nodes, m, seed=rng)

    # Generate the consensus graph, ensure that it is a connected graph
    G = ensure_connectedness(graph_generator)
    if G is None:
        raise exceptions.MaxIterReachedException(
            "I cannot create a connected consensus graph with given model parameter."
        )

    return G

def gen_views(n_views, Gc, perturbation, rng=None):
    """Generate view graphs from a given consensus graph using edge swapping.

    Parameters
    ----------
    n_views : int
        Number of view graphs to generate.
    Gc : nx.Graph
        The consensus graph.
    perturbation : float
        Fraction of edges to swap. 
    rng : _type_, optional
        _description_, by default None

    Returns
    -------
    Gv : list of nx.Graph
        List of generated views graphs. 

    Raises
    ------
    MaxIterReachedException
        This function keeps producing a view graph until finding a connected
        one. Maximum number of times it runs to produce the view graph is set to
        500. If this reached it will raise an error. 
    """
    if rng is None: 
        rng = np.random.default_rng()

    n_swaps = int(Gc.number_of_edges()*perturbation)
    generator = lambda : swap_edges(Gc, n_swaps, rng=rng)

    # Generate view graphs from consensus graphs    
    Gv = []
    for s in range(n_views):
        G = ensure_connectedness(generator)
        if G is None:
            raise exceptions.MaxIterReachedException(
                "I cannot create connected view graphs with the given consensus graph."
            )
        else: 
            Gv.append(G)
        
    return Gv