import copy
import networkx as nx
import numpy as np

def ensure_connectedness(generator):
    """Draw a random graph until finding a connected one."""
    i = 1
    while True:
        G = generator()
        if nx.is_connected(G):
            return G
        else:
            i += 1

        if i>500:
            return None
        
# def swap_edges(G, n_swaps):
#     """Perform edge swapping. 
    
#     The method randomly select an edge: (a, b) and two nodes c and d that are
#     not connected. Edge (a, b) is then removed and a new edge (c, d) is added.
#     All attributes of (a, b) are also transfered to the newly added edge (c, d).
#     Edge swapping is done in place. There is an edge swapping function in
#     networkx, but it does not handle edge attributes.

#     Parameters
#     ----------
#     G : nx.Graph
#         An undirected graph.
#     n_swaps : int
#         Number of edge swap to perform.

#     Returns
#     -------
#     G : nx.Graph
#         The new graph generated by edge swapping.
#     """
#     G = copy.deepcopy(G)

#     n = G.number_of_nodes()
#     m = G.number_of_edges()

#     # If the graph is fully connected, there is nothing to randomize
#     if m == (n*(n-1)/2):
#         return
    
#     # Get the nodes of the graph as a list
#     node_labels = [i for i in G.nodes]

#     rng = np.random.default_rng()

#     max_attempt = m
    
#     for _ in range(n_swaps):     

#         # Select an edge to swap: ensures that a and b have at least two edges
#         attempt = 0
#         while attempt <= max_attempt:
#             a = rng.choice(node_labels)

#             if G.degree(a) > 1:
#                 b = rng.choice(list(G.neighbors(a)))
            
#                 if G.degree(b) > 1:
#                     break

#         # Select two nodes to connect with an edge
#         attempt = 0
#         while attempt <= max_attempt:
#             c = rng.choice(node_labels)
#             d = rng.choice(node_labels)

#             if c != b and c != a and d!=a and d != b and (not G.has_edge(c, d)):
#                 break
                
#             attempt += 1
        
#         # Rewire the edge
#         attr_ab = G[a][b]
#         G.remove_edge(a, b)
#         G.add_edge(c, d, **attr_ab)

#     return G

def gen_consensus_graph(n_nodes, graph_generator, p=None, m=None, rng=None):
    """Generate the consensus graph using Erdos-Renyi or Barabasi-Albert model.

    Parameters
    ----------
    n_nodes : int
        Number of nodes
    graph_generator : str
        The model to use. Must be 'er' or 'ba'.
    p : float, optional
        The edge probability for Erdos-Renyi model. Ignored if graph_generator
        is 'ba'. By default None.
    m : int, optional
        Growth parameter for Barabasi-Albert model. Ignored if graph generator
        is 'er'. By default None
    rng : np.random.Generator, optional
        Random number generator. If one wants the function to return the same 
        graph every time, this needs to be set. By default None

    Returns
    -------
    G : nx.Graph
        Generated consensus graph

    Raises
    ------
    Exception
        This function keeps drawing a random graph until finding a connected
        one. Maximum number of draws is set to 500. If this reached it will
        raise an error. 
    """
    if rng is None: 
        rng = np.random.default_rng()

    if graph_generator == "er":
        graph_generator = lambda : nx.erdos_renyi_graph(n_nodes, p, seed=rng)
    elif graph_generator == "ba":
        graph_generator = lambda : nx.barabasi_albert_graph(n_nodes, m, seed=rng)

    # Generate the consensus graph, ensure that it is a connected graph
    G = ensure_connectedness(graph_generator)
    if G is None:
        raise Exception("I cannot create a connected consensus graph with "   
                        "given model parameter.")

    return G

# def gen_views(n_views, Gc, perturbation):
#     n_swaps = int(Gc.number_of_edges()*perturbation)
#     generator = lambda s: edge_swap.topological(Gc, n_swaps, seed=s)
#     elif view_gen["method"] == "add_edge":
#         n_edges_to_add = int(Gc.number_of_edges()*view_gen["add_frac"])
#         generator = lambda s: add_edges(Gc, n_edges_to_add, seed=s)
#     elif view_gen["method"] == "model_diff":
#         n_nodes = Gc.number_of_nodes()
#         n_edges = Gc.number_of_edges()
#         n_edges_to_change = int(n_edges*view_gen["edge_perturb"])

#         rng = np.random.default_rng(seed)
#         edges_to_change = []
#         while len(edges_to_change) < n_edges_to_change:
#             i = rng.integers(0, n_nodes)
#             j = rng.integers(0, n_nodes)

#             if i == j:
#                 continue
#             if (i, j) not in Gc: 
#                 edges_to_change.append((i, j))
        
#         generator = lambda s: model_diff(
#             Gc, edges_to_change, consensus_gen, view_gen, n_views, seed=s
#         )
#     elif view_gen["method"] == "model_diff_with_consensus":
#         Gv = model_diff_with_consensus(
#             n_views, Gc, view_gen
#         )

#         return Gv

#     # Generate view graphs from consensus graphs    
#     Gv = []
#     for s in range(n_views):
#         G = ensure_connectedness(generator, rng_seed(seed, mult=567*s))
#         if G is None:
#             raise Exception("I cannot create a connected view graph with "   
#                             "the given consensus graph.")
#         else: 
#             Gv.append(G)
        
#     return Gv